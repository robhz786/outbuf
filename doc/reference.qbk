[/==============================================================================
    Use, modification and distribution is subject to the Boost Software License,
    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
    http://www.boost.org/LICENSE_1_0.txt)
===============================================================================/]

[section Reference]

[section Header `boost/outbuf.hpp`]

[#min_size_after_recycle]
[section `contexpr` function template `min_size_after_recycle`]
[table
[[`template <typename CharT>`[br]
  `constexpr std::size_t min_size_after_recycle();`]]
[[[variablelist
    [[Return value]
     [Implementation-defined value greater than or equal to `64`.]]]]]
]

[endsect]

[section Class template `underlying_outbuf`]

``
namespace boost {
namespace outbuf {

template <typename CharT>
class underlying_outbuf;
{
public:

    using char_type = CharT;

    underlying_outbuf(const underlying_outbuf&) = delete;
    underlying_outbuf(underlying_outbuf&&) = delete;
    underlying_outbuf& operator=(const underlying_outbuf&) = delete;
    underlying_outbuf& operator=(underlying_outbuf&&) = delete;

    virtual ~underlying_outbuf() = default;

    CharT* pos() const noexcept;
    CharT* end() const noexcept;
    std::size_t size() const noexcept;
    bool good() const noexcept;
    void advance_to(CharT* p) [[expects: pos() <= p && p <= end() ]];
    void advance(std::size_t n) [[expects: pos() + n <= end() ]];
    void ensure(std::size_t s) [[ expects: s <= min_size_after_recycle<CharT>() ]]
                               [[ ensures: pos() + s <= end(); ]];

    virtual bool recycle() [[ ensures: pos() + min_size_after_recycle<CharT>()  <= end() ]]
                           [[ ensures g: g == good() ]]
                           = 0;
protected:

    underlying_outbuf(CharT* pos_, CharT* end_);

    underlying_outbuf(CharT* pos_, std::size_t n);

    void set_pos(CharT* p);
    void set_end(CharT* e);
    void set_good(true g) noexcept;
};

// global functions

template <typename CharT>
void puts( underlying_outbuf<CharT>& dest, const CharT* str, const CharT* str_end );

template <typename CharT, bool NoExcept>
void puts( underlying_outbuf<CharT>& dest, const CharT* str, std::size_t str_len );

void puts( underlying_outbuf<char>& dest, const char* str );

void puts( underlying_outbuf<wchar_t>& dest, const char* str );

template <typename CharT, bool NoExcept>
void putc( underlying_outbuf<Chart, NoExcept>& dest, CharT c ) noexcept(NoExcept) ;

// namespace boost
// namespace outbuf
``

[endsect]

[h4 Public member functions]

[#underlying_outbuf_recycle]
[table
[[`virtual void recycle() noexcept(NoExcept) = 0;`]]
[[[variablelist
    [[ Postcondition]
      [ `size() >=  `[link min_size_after_recycle `min_size_after_recycle`]`<CharT>()`.]
      [ The range \u005B `pos()`, `end()` \u0029 is valid accessible memory area ]
      [ If the return value of `good()` was `false` before this call to `recycle()`,
        then `good()` remains returning `false`.]]
]]]
]

[table
[[`void ensure(std::size_t s)`]]
[[[variablelist
    [[Effect]
      [calls `recycle()` if `size() < s`.]]
    [[Precondition]
      [`s <= `[link min_size_after_recycle `min_size_after_recycle`]`<CharT>()` ]]
    [[Postcondition]
      [`size() >= s`]]
]]]
]

[table
[[`void advance_to(CharT* p)`]]
[[[variablelist
    [[Effect]
     [Advance the buffer's position]]
    [[Preconditions]
     [`pos() <= p` ]
     [`p <= end()` ]]
    [[Postconditions]
     [`pos() == p`]]
]]]
]

[table
[[`void advance(std::size_t n)`]]
[[[variablelist
    [[Effect]
     [same as `advance_to(pos() + n)`]]
    [[Preconditions]
     [`n <= size()` ]]
]]]
]

[table
[[`void advance()`]]
[[[variablelist
    [[Effect]
     [same as `advance(1)`]]
    [[Preconditions]
     [`pos() != end()` ]]
]]]
]

[table
[[`std::size_t size() const`]]
[[[variablelist
    [[Return value]
     [`end() - pos()` ]]
]]]
]

[h4 Protected member functions]

[table
[[`underlying_outbuf(CharT* pos_, CharT* end_)`]]
[[[variablelist
    [[Preconditions]
      [/`pos_ != nullptr`]
      [/`end_ != nullptr`]
      [`pos_ <= end_`]
      [ The range \u005B `pos_`, `end_` \u0029
        must be an accessible memory area]]
    [[Postconditions]
      [`pos() == pos_`]
      [`end() == end_`]
      [`good() == true` ]]
]]]
]

[table
[[`underlying_outbuf(CharT* pos_, std::size_t n)`]]
[[[variablelist
    [[Preconditions]
      [/`pos_ != nullptr`]
      [ The range \u005B `pos_`, `pos_` + n \u0029
        must be an accessible memory area]]
    [[Postconditions]
      [`pos() == pos_`]
      [`end() == pos_ + n`]
      [`good() == true` ]]
]]]
]

[table
[[`void set_pos(CharT* p)`]]
[[[variablelist
    [[Postconditions]
      [`pos() == p`]]
]]]
]

[table
[[`void set_end(CharT* e)`]]
[[[variablelist
    [[Postconditions]
      [`end() == e`]]
]]]
]

[table
[[`void set_good(bool g)`]]
[[[variablelist
    [[Postconditions]
      [`good() == g`]]
]]]
]


[h4 Global functions]

/To-do/

[section Class template `basic_outbuf`]

[h4 Synopsis]

``
namespace boost {
namespace outbuf {

template <bool NoExcept, typename CharT>
class basic_outbuf;

using outbuf    = basic_outbuf<false, char>;
using u8outbuf  = basic_outbuf<false, char8_t>;
using u26outbuf = basic_outbuf<false, char16_t>;
using u32outbuf = basic_outbuf<false, char32_t>;
using woutbuf   = basic_outbuf<false, wchar_t>;

using outbuf_noexcept    = basic_outbuf<true, char>;
using u8outbuf_noexcept  = basic_outbuf<true, char8_t>;
using u26outbuf_noexcept = basic_outbuf<true, char16_t>;
using u32outbuf_noexcept = basic_outbuf<true, char32_t>;
using woutbuf_noexcept   = basic_outbuf<true, wchar_t>;

template <typename CharT>
using underlying_outbuf_char_type = /*see below*/;

template <typename CharT>
using underlying_outbuf_alias
= underlying_outbuf<underlying_outbuf_char_type<CharT>>;

template <typename CharT>
class basic_outbuf<false, Chart>: private underlying_outbuf_alias<CharT>
{
public:

    using char_type = CharT;
    basic_outbuf(const basic_outbuf&) = delete;
    basic_outbuf(basic_outbuf&&) = delete;
    basic_outbuf& operator=(const basic_outbuf&) = delete;
    basic_outbuf& operator=(basic_outbuf&&) = delete;

    virtual ~basic_outbuf() = default;

    underlying_outbuf_alias<CharT>& as_underlying() noexcept;

    CharT* pos() const noexcept;
    CharT* end() const noexcept;
    std::size_t size() const noexcept;
    bool good() const noexcept;
    void advance_to(CharT* p) [[expects: pos() <= p && p <= end() ]];
    void advance(std::size_t n) [[expects: pos() + n <= end() ]];
    void ensure(std::size_t s) [[ expects: s <= min_size_after_recycle<CharT>() ]]
                               [[ ensures: pos() + s <= end(); ]];

    virtual bool recycle() [[ ensures: pos() + min_size_after_recycle<CharT>()  <= end() ]]
                           [[ ensures g: g == good() ]]
                           = 0;
protected:

    basic_outbuf(CharT* pos_, CharT* end_);
    basic_outbuf(CharT* pos_, std::size_t s);
    void set_pos(CharT* p);
    void set_end(CharT* e);
    void set_good(true g) noexcept;
};

template <typename CharT>
class basic_outbuf<true, Chart>: public basic_outbuf<false, Chart>
{
public:

    virtual void recycle() noexcept [[ ensures: size() >= min_size_after_recycle<CharT>() ]]
                                    [[ ensures g: g == good() ]]
                                    = 0;

    bool ensure(std::size_t s) [[ expects: s <= min_size_after_recycle<CharT>() ]]
                               [[ ensures: size() >= s; ]];

protected:

    using basic_outbuf<false, Chart>::basic_outbuf;
};

// global functions

template <typename CharT>
inline void puts( boost::outbuf::basic_outbuf<true, CharT>& ob
                , const CharT* str
                , std::size_t len );

template <typename CharT>
inline void puts( boost::outbuf::basic_outbuf<false, CharT>& ob
                , const CharT* str
                , std::size_t len );

template <typename CharT>
inline void puts( boost::outbuf::basic_outbuf<true, CharT>& ob
                , const CharT* str
                , const CharT* str_end );

template <typename CharT>
inline void puts( boost::outbuf::basic_outbuf<false, CharT>& ob
                , const CharT* str
                , const CharT* str_end );

inline void puts( boost::outbuf::basic_outbuf<true, char>& ob
                , const char* str );

inline void puts( boost::outbuf::basic_outbuf<false, char>& ob
                , const char* str );

inline void puts( boost::outbuf::basic_outbuf<true, wchar_t>& ob
                , const wchar_t* str );

inline void puts( boost::outbuf::basic_outbuf<false, wchar_t>& ob
                , const wchar_t* str );

template <typename CharT>
void putc( boost::outbuf::basic_outbuf<true, CharT>& ob, CharT c );

template <typename CharT>
void putc( boost::outbuf::basic_outbuf<false, CharT>& ob, CharT c );

} // namespace outbuf
} // namespace boost
``

[table
[[`underlying_outbuf_alias<CharT>& as_underlying() noexcept;`]]
[[[variablelist
    [[Effect]
      [Returns the private `underlying_outbuf_alias<CharT>` subobject.]]
]]]
]

[endsect]

[section Class template `basic_cstr_writer`]
[h4 Synopsis]
``
namespace boost {
namespace outbuf {

template <typename CharT>
class basic_cstr_writer final: public boost::outbuf::basic_outbuf<true, CharT>
{
public:

    basic_cstr_writer(CharT* dest, CharT* dest_end);

    basic_cstr_writer(CharT* dest, std::size_t len);

    template <std::size_t N>
    basic_cstr_writer(CharT (&dest)[N]);

    void recycle() noexcept override;

    struct result
    {
        CharT* ptr;
        bool truncated;
    };

    result finish();
}

using u8cstr_writer = basic_cstr_writer<char8_t>;
using cstr_writer = basic_cstr_writer<char>;
using u16cstr_writer = basic_cstr_writer<char16_t>;
using u32cstr_writer = basic_cstr_writer<char32_t>;
using wcstr_writer = basic_cstr_writer<wchar_t>;

} // namespace outbuf
} // namespace boost
``
[table
[[`basic_cstr_writer(CharT* dest, CharT* dest_end);`]]
[[
  [variablelist
    [[ Preconditions]
      [ `dest < dest_end` ]]
    [[ Postconditions]
      [ `good() == true`]
      [ `pos() == dest`]
      [ `end() == dest_end - 1`]]]
]]
]
[table
[[`basic_cstr_writer(CharT* dest, std::size_t len);`]]
[[
  [variablelist
    [[ Preconditions]
      [ `len != 0` ]]
    [[ Postconditions]
      [ `good() == true`]
      [ `pos() == dest`]
      [ `end() == dest + len - 1`]]]
]]
]
[table
[[`template <std::size_t N>`[br]
  `basic_cstr_writer(CharT (&dest)[N]);`
]]
[[
  [variablelist
    [[ Postconditions]
      [ `good() == true`]
      [ `pos() == dest`]
      [ `end() == dest + N - 1`]]]
]]
]
[table
[[`void recycle() noexcept`]]
[[
  [variablelist
    [[ Postcondition]
      [ `good() == false`]
      [ `pos() == `[link garbage_buffer `outbuf_garbage_buf`]`<CharT>()`]
      [ `end() == `[link garbage_buffer `outbuf_garbage_buf_end`]`<CharT>()`]]]
]]
]
[table
[[`result finish()`]]
[[
  [variablelist
    [[ Effects ]
     [ `set_good(false)` ]
     [ Assign to '\0' the position after the last written character in
       memory area used to initialize this object ]]
    [[ Return value ]
     [ `result::truncated` is `true` if and only if `recycle` has ever
       been called in this object ]
     [ `retulr::ptr` is the position after the last written character in
       memory area used to initialize this object ]]]
]]
]
[endsect]


[section Class template `discarded_outbuf`]

A dummy outbuf that igores everything that is written into its buffer.

[h4 Synopsis]
``
namespace boost {
namespace outbuf {

template <typename CharT>
class discarded_outbuf final: public basic_outbuf<true, CharT>
{
public:
    discarded_outbuf();
    ~discarded_outbuf();
    void recycle() noexcept override;
};

} // namespace outbuf
} // namespace boost
``

[h4 Public member functions]
[table
[[`discarded_outbuf();`]]
[[[variablelist
    [[ Postcondition]
      [ `good() == false`]
      [ `pos() == `[link garbage_buffer `outbuf_garbage_buf`]`<CharT>()`]
      [ `end() == `[link garbage_buffer `outbuf_garbage_buf_end`]`<CharT>()`]]]
]]
]

[table
[[`recycle() noexcept;`]]
[[[variablelist
    [[ Postcondition]
      [ `good() == false`]
      [ `pos() == `[link garbage_buffer `outbuf_garbage_buf`]`<CharT>()`]
      [ `end() == `[link garbage_buffer `outbuf_garbage_buf_end`]`<CharT>()`]]]
]]
]
[endsect]

[#garbage_buffer]
[section The garbage buffer]

The `outbuf_garbage_buf()` function template return a memory area
that is never supposed to be read. It can be used when implementing
a class that derives from `basic_outbuf` to set the buffer when the
state is "bad".
``
namespace boost {
namespace outbuf {

template <typename CharT> CharT* outbuf_garbage_buf();
template <typename CharT> CharT* outbuf_garbage_buf_end();

} // namespace outbuf
} // namespace boost
``

[section]

[endsect]

[endsect]
[endsect]

[section Header `boost/outbuf/string.hpp`]

[section Class template `basic_string_maker`]
[h4 Sypnosis]
``
namespace boost {
namespace outbuf {

template < bool NoExcept
         , typename CharT
         , typename Traits = std::char_traits<CharT>
         , typename Allocator = std::allocator<CharT> >
class basic_string_maker final: public boost::outbuf::basic_outbuf<NoExcept, CharT>
{
public:

    basic_string_maker();

    void recycle() noexcept(NoExcept) override;

    std::basic_string<Char, Traits, Allocator> finish();
};

template <bool NoExcept>
using u8string_maker = basic_string_maker<NoExcept, char8_t>;
template <bool NoExcept>
using string_maker = basic_string_maker<NoExcept, char>;
template <bool NoExcept>
using u16string_maker = basic_string_maker<NoExcept, char16_t>;
template <bool NoExcept>
using u32string_maker = basic_string_maker<NoExcept, char32_t>;
template <bool NoExcept>
using wstring_maker = basic_string_maker<NoExcept, wchar_t>;

} // namespace outbuf
} // namespace boost
``
[h4 Member functions]

[table
[[`void recycle() noexcept(NoExcept);`]]
[[[variablelist
    [[ Effects ]
      [ If `good() == true`,
        appends the range \u005B `p0`, `pos()` \u0029 into the
        internal string, where `p0` is the value `pos()` would have returned
        if called before any call to `advance` or `advance_to` in
        this object since the last time `recycle` was called in this
        object, or, in case `recycle` was not called in this object yet,
        since this object was constructed. ]
      [ If and exception is thrown and `NoExcept` is `true`, then holds
        the exception object with a `std::exception_ptr` that will further
        be rethrow by `finish()`. ]
      [ If and exception is thrown, calls `set_good(false)` regardless
        of the value of `NoExcept`. ]
      [ Calls `set_pos` and/or `set_end`. ]]
    [[ Postcondition]
      [ `size() >=  `[link min_size_after_recycle `min_size_after_recycle`]`<CharT>()`.]]
]]]
]

[table
[[`std::basic_string<Char, Traits, Allocator> finish();`]]
[[[variablelist
    [[Effects]
      [ If `good() == false` and `NoExcept` is `true`, rethrows the exception
        caught on `recycle()` ]
      [ Move the content of the internal string to the return value. ]]
    [[Postcondition]
     [`good() == false`]]
    [[Return value]
     [The internal string.]]]
]]
]

[endsect]

[section Class template `basic_string_appender`]

[h4 Sypnosis]
``
namespace boost {
namespace outbuf {

template < bool NoExcept
         , typename CharT
         , typename Traits = std::char_traits<CharT>
         , typename Allocator = std::allocator<CharT> >
class basic_string_appender final: public boost::outbuf::basic_outbuf<NoExcept, CharT>
{
public:

    explicit basic_string_appender(std::basic_string<Char, Traits, Allocator>&);

    void recycle() noexcept(NoExcept) override;

    void finish();
};

template <bool NoExcept>
using u8string_appender = basic_string_appender<NoExcept, char8_t>;
template <bool NoExcept>
using string_appender = basic_string_appender<NoExcept, char>;
template <bool NoExcept>
using u16string_appender = basic_string_appender<NoExcept, char16_t>;
template <bool NoExcept>
using u32string_appender = basic_string_appender<NoExcept, char32_t>;
template <bool NoExcept>
using wstring_appender = basic_string_appender<NoExcept, wchar_t>;

} // namespace outbuf
} // namespace boost
``

[h4 Public member functions]
[table
[[`void recycle() noexcept(NoExcept);`]]
[[[variablelist
    [[ Effects ]
      [ If `good() == true`,
        appends the range \u005B `p0`, `pos()` \u0029 into the
        internal string reference used to intialize this object,
        where `p0` is the value `pos()` would have returned
        if called before any call to `advance` or `advance_to` in
        this object since the last time `recycle` was called in this
        object, or, in case `recycle` was not called in this object yet,
        since this object was constructed. ]
      [ If and exception is thrown and `NoExcept` is `true`, then holds
        the exception object with a `std::execption_ptr` that will further
        be rethrow by `finish()`. ]
      [ If and exception is thrown, calls `set_good(false)` regardless
        of the value of `NoExcept`. ]
      [ Calls `set_pos` and/or `set_end`. ]]
   [[ Postcondition]
      [ `size() >=  `[link min_size_after_recycle `min_size_after_recycle`]`<CharT>()`.]]
]]]
]

[table
[[`void finish();`]]
[[[variablelist
    [[Effects]
      [ If `good() == false` and `NoExcept` is `true`, rethrows the exception
        caught on `recycle()` ]]
    [[Postconditions]
     [`good() == false`]]
]]]
]

[endsect]
[endsect]
[section Header `boost/outbuf/cfile.hpp`]

[section Class template narrow_cfile_writer]

[h4 Sypnosis]
``
namespace boost {
namespace outbuf {

template <typename CharT>
class narrow_cfile_writer final: public boost::outbuf::basic_outbuf<false, CharT>
{
public:
    explicit narrow_cfile_writer(std::FILE* dest_)

    void recycle() override;

    struct result
    {
        std::size_t count;
        bool success;
    };

    result finish();
};

} // namespace outbuf
} // namespace boost
``
[h4 Public member functions]
[table
[[`void recycle() noexcept(NoExcept);`]]
[[[variablelist
    [[ Effects ]
      [ If `good() == true`, calls
        `std::fwrite(p0, pos() - p0, sizeof(CharT), dest)`, where
        [itemized_list
          [ `p0` is the value `pos()` would have returned if called before
            any call to `advance` or `advance_to` in this object since
            the last time `recycle` was called in this object, or,
            in case `recycle` was not called in this object yet,
            since this object was constructed. ]
          [ `dest` is the `FILE*` used to initialize this object. ]]]
      [If the returned value of `std::fwrite` is less then `pos() - p0`, calls
        `set_good(false)`.]
      [ Calls `set_pos` and/or `set_end`. ]]
   [[ Postcondition]
      [ `size() >=  `[link min_size_after_recycle `min_size_after_recycle`]`<CharT>()`.]]
]]]
]

[table
[[`void finish()`]]
[[[variablelist
    [[Effect]
      [Calls `recycle()` and `set_good(false)`. ]]
    [[Return value]
      [`result::count` is the sum of the values returned by `std::fwrite`.]
      [`result::success` is the value `good()` would return
        before this call to `finish()`. ]]
]]]
]


[endsect]
[section Class wide_cfile_writer]
[h4 Synopsis]
``
namespace boost {
namespace outbuf {

class wide_cfile_writer final: public boost::outbuf::basic_outbuf<false, wchar_t>
{
public:
    explicit wide_cfile_writer(std::FILE* dest)

    void recycle() override;

    struct result
    {
        std::size_t count;
        bool success;
    };

    result finish();
};

} // namespace outbuf
} // namespace boost
``
[h4 Public member functions]

[table
[[`void recycle() noexcept(NoExcept);`]]
[[[variablelist
    [[ Effects ]
      [ If `good() == true`, for each character `ch` in the range
        \u005B `p0`, `pos()` \u0029 calls `std::fputwc(ch, dest)`,
        until `WEOF` is returned or the whole range is read,
        where
        [itemized_list
          [ `p0` is the value `pos()` would have returned if called before
            any call to `advance` or `advance_to` in this object since
            the last time `recycle` was called in this object, or,
            in case `recycle` was not called in this object yet,
            since this object was constructed. ]
          [ `dest` is the `FILE*` used to initialize this object. ]]]
      [If `std::fputwc` returns `WEOF`, calls `set_good(false)`.]
      [ Calls `set_pos` and/or `set_end`. ]]
   [[ Postcondition]
      [ `size() >=  `[link min_size_after_recycle `min_size_after_recycle`]`<CharT>()`.]]
]]]
]

[table
[[`void finish()`]]
[[[variablelist
    [[Effect]
      [Calls `recycle()` and `set_good(false)`. ]]
    [[Return value]
      [`result::count` is the number of succesful calls `std::fputwc`
       ( that did not return `WEOF` ). ]
      [`result::success` is the value `good()` would return
        before this call to `finish()`. ]]
]]]
]

[endsect]
[endsect]
[section Header `boost/outbuf/streambuf.hpp`]
[section Class template basic_streambuf_writer]

[h4 Synopsis]
``
namespace boost {
namespace outbuf {

template <typename CharT, typename Traits = std::char_traits<CharT> >
class basic_streambuf_writer final
    : public boost::outbuf::basic_outbuf<false, CharT>
{
public:

    explicit basic_streambuf_writer(std::basic_streambuf<CharT, Traits>&)

    void recycle() override;

    struct result
    {
        std::streamsize count;
        bool success;
    };

    result finish();
};

using streambuf_writer
    = basic_streambuf_writer<char, std::char_traits<char> >;

using wstreambuf_writer
    = basic_streambuf_writer<wchar_t, std::char_traits<wchar_t> >;

} // namespace outbuf
} // namespace boost
``
[h4 Public member functions]

[table
[[`void recycle() noexcept(NoExcept);`]]
[[[variablelist
    [[ Effects ]
      [ If `good() == true`, calls
        `dest.sputn(p0, pos() - p0)`, where
        [itemized_list
          [ `p0` is the value `pos()` would have returned if called before
            any call to `advance` or `advance_to` in this object since
            the last time `recycle` was called in this object, or,
            in case `recycle` was not called in this object yet,
            since this object was constructed. ]
          [ `dest` is the reference used to initialize this object. ]]]
      [If the returned value of `dest.sputn` is less then `pos() - p0`, calls
        `set_good(false)`.]
      [ Calls `set_pos` and/or `set_end`. ]]
   [[ Postcondition]
      [ `size() >=  `[link min_size_after_recycle `min_size_after_recycle`]`<CharT>()`.]]
]]]
]

[table
[[`void finish()`]]
[[[variablelist
    [[Effect]
      [Calls `recycle()` and `set_good(false)`. ]]
    [[Return value]
      [`result::count` is the sum of the values returned by `dest.sputn`.]
      [`result::success` is the value `good()` would return
        before this call to `finish()`. ]]
]]]
]


[endsect]
[endsect]
[endsect]
