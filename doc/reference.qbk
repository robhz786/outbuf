[/==============================================================================
    Use, modification and distribution is subject to the Boost Software License,
    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
    http://www.boost.org/LICENSE_1_0.txt)
===============================================================================/]

[section Reference]

[section Header `boost/outbuf.hpp`]

[#min_size_after_recycle]
[section function template `min_size_after_recycle`]
[table
[[`template <typename CharT>`[br]
  `constexpr std::size_t min_size_after_recycle();`]]
[[[variablelist
    [[Return value]
     [Implementation-defined value greater than or equal to `64`.]]]]]
]

[endsect]

[section Class template `underlying_outbuf`]

``
namespace boost {
namespace outbuf {

template <typename CharT>
class underlying_outbuf;
{
public:

    using char_type = CharT;

    underlying_outbuf(const underlying_outbuf&) = delete;
    underlying_outbuf(underlying_outbuf&&) = delete;
    underlying_outbuf& operator=(const underlying_outbuf&) = delete;
    underlying_outbuf& operator=(underlying_outbuf&&) = delete;

    virtual ~underlying_outbuf() = default;

    CharT* pos() const noexcept;
    CharT* end() const noexcept;
    bool good() const noexcept;
    void advance_to(CharT* p) [[expects: pos() <= p && p <= end() ]];
    void advance(std::size_t n) [[expects: pos() + n <= end() ]];
    void ensure(std::size_t s) [[ expects: s <= min_size_after_recycle<CharT>() ]]
                               [[ ensures: pos() + s <= end(); ]];

    virtual bool recycle() [[ ensures: pos() + min_size_after_recycle<CharT>()  <= end() ]]
                           [[ ensures g: g == good() ]]
                           = 0;
protected:

    underlying_outbuf(CharT* pos_, CharT* end_);

    underlying_outbuf(CharT* pos_, std::size_t s);

    void set_pos(CharT* p);
    void set_end(CharT* e);
    void set_good(true g) noexcept;
};

// global functions

template <typename CharT>
void puts( underlying_outbuf<CharT>& dest, const CharT* str, const CharT* str_end );

template <typename CharT, bool NoExcept>
void puts( underlying_outbuf<CharT>& dest, const CharT* str, std::size_t str_len );

void puts( underlying_outbuf<char>& dest, const char* str );

void puts( underlying_outbuf<wchar_t>& dest, const char* str );

template <typename CharT, bool NoExcept>
void putc( underlying_outbuf<Chart, NoExcept>& dest, CharT c ) noexcept(NoExcept) ;

// namespace boost
// namespace outbuf
``

[endsect]

[h4 Member functions]

[#underlying_outbuf_recycle]
[table
[[`virtual void recycle() noexcept(NoExcept) = 0;`]]
[[[variablelist

    [[ Postcondition]
      [ `pos() +  min_buff_size <= end()`.]
      [ The range \u005B `pos()`, `end()` \u0029 is valid accessible memory area ]
      [ If the return value of `good()` was `false` before this call to `recycle()`,
        then `good()` remains returning `false`.]]
]]]
]

[h4 Global functions]

/To-do/

[section Class template `basic_outbuf`]

[h4 Synopsis]

``
namespace boost {
namespace outbuf {

template <bool NoExcept, typename CharT>
class basic_outbuf;

using outbuf    = basic_outbuf<false, char>;
using u8outbuf  = basic_outbuf<false, char8_t>;
using u26outbuf = basic_outbuf<false, char16_t>;
using u32outbuf = basic_outbuf<false, char32_t>;
using woutbuf   = basic_outbuf<false, wchar_t>;

using outbuf_noexcept    = basic_outbuf<true, char>;
using u8outbuf_noexcept  = basic_outbuf<true, char8_t>;
using u26outbuf_noexcept = basic_outbuf<true, char16_t>;
using u32outbuf_noexcept = basic_outbuf<true, char32_t>;
using woutbuf_noexcept   = basic_outbuf<true, wchar_t>;

template <typename CharT>
using underlying_outbuf_char_type = /*see below*/;

template <typename CharT>
using underlying_outbuf_alias
= underlying_outbuf<underlying_outbuf_char_type<CharT>>;

template <typename CharT>
class basic_outbuf<false, Chart>: private underlying_outbuf_alias<CharT>
{
public:

    using char_type = CharT;
    basic_outbuf(const basic_outbuf&) = delete;
    basic_outbuf(basic_outbuf&&) = delete;
    basic_outbuf& operator=(const basic_outbuf&) = delete;
    basic_outbuf& operator=(basic_outbuf&&) = delete;

    virtual ~basic_outbuf() = default;

    underlying_outbuf_alias<CharT>& as_underlying() noexcept;

    CharT* pos() const noexcept;
    CharT* end() const noexcept;
    bool good() const noexcept;
    void advance_to(CharT* p) [[expects: pos() <= p && p <= end() ]];
    void advance(std::size_t n) [[expects: pos() + n <= end() ]];
    void ensure(std::size_t s) [[ expects: s <= min_size_after_recycle<CharT>() ]]
                               [[ ensures: pos() + s <= end(); ]];

    virtual bool recycle() [[ ensures: pos() + min_size_after_recycle<CharT>()  <= end() ]]
                           [[ ensures g: g == good() ]]
                           = 0;
protected:

    basic_outbuf(CharT* pos_, CharT* end_);
    basic_outbuf(CharT* pos_, std::size_t s);
    void set_pos(CharT* p);
    void set_end(CharT* e);
    void set_good(true g) noexcept;
};

template <typename CharT>
class basic_outbuf<true, Chart>: public basic_outbuf<false, Chart>
{
public:

    virtual void recycle() noexcept [[ ensures: size() >= min_size_after_recycle<CharT>() ]]
                                    [[ ensures g: g == good() ]]
                                    = 0;

    bool ensure(std::size_t s) [[ expects: s <= min_size_after_recycle<CharT>() ]]
                               [[ ensures: size() >= s; ]];

protected:

    using basic_outbuf<false, Chart>::basic_outbuf;
};

// global functions

template <typename CharT>
inline void puts( boost::outbuf::basic_outbuf<true, CharT>& ob
                , const CharT* str
                , std::size_t len );

template <typename CharT>
inline void puts( boost::outbuf::basic_outbuf<false, CharT>& ob
                , const CharT* str
                , std::size_t len );

template <typename CharT>
inline void puts( boost::outbuf::basic_outbuf<true, CharT>& ob
                , const CharT* str
                , const CharT* str_end );

template <typename CharT>
inline void puts( boost::outbuf::basic_outbuf<false, CharT>& ob
                , const CharT* str
                , const CharT* str_end );

inline void puts( boost::outbuf::basic_outbuf<true, char>& ob
                , const char* str );

inline void puts( boost::outbuf::basic_outbuf<false, char>& ob
                , const char* str );

inline void puts( boost::outbuf::basic_outbuf<true, wchar_t>& ob
                , const wchar_t* str );

inline void puts( boost::outbuf::basic_outbuf<false, wchar_t>& ob
                , const wchar_t* str );

template <typename CharT>
void putc( boost::outbuf::basic_outbuf<true, CharT>& ob, CharT c );

template <typename CharT>
void putc( boost::outbuf::basic_outbuf<false, CharT>& ob, CharT c );

} // namespace outbuf
} // namespace boost
``

[endsect]

[section Class template `basic_cstr_writer`]
[h4 Synopsis]
``
namespace boost {
namespace boost {

} // namespace outbuf
} // namespace boost
``
[endsect]


[section Class template `discarded_outbuf`]

A dummy outbuf that igores everything that is written into its buffer.

[h4 Synopsis]
``
namespace boost {
namespace boost {

template <typename CharT>
class discarded_outbuf final: public basic_outbuf<true, CharT>
{
public:
    discarded_outbuf();
    ~discarded_outbuf();
    void recycle() noexcept override;
};

} // namespace outbuf
} // namespace boost
``

[h4 Member functions]
[table
[[`discarded_outbuf();`]]
[[[variablelist
    [[Effects]
     [[itemized_list
       [Initializes `basic_outbuf<true, CharT>` base
        with [link garbage_buffer `outbuf_garbage_buf`]`<CharT>()` and
        [link garbage_buffer `outbuf_garbage_buf_end`]`<CharT>()`.]
       [Calls `set_good(false)`.]]]]
    [[Posconditions]
     [Return value of `good()` is `false`]]]]]
]

[table
[[`recylce() noexcept;`]]
[[[variablelist
    [[Effect]
     [calls `set_pos(outbuf_garbage_buf<CharT>())`]]]]]
]
[endsect]

[#garbage_buffer]
[section The garbage buffer]

The `outbuf_garbage_buf()` function template return a memory area
that is never supposed to be read. It can be used when implementing
a class that derives from `basic_outbuf` to set the buffer when the
state is "bad".
``
namespace boost {
namespace boost {

template <typename CharT> CharT* outbuf_garbage_buf();
template <typename CharT> CharT* outbuf_garbage_buf_end();

} // namespace outbuf
} // namespace boost
``

[section]

[endsect]

[endsect]
[endsect]

[section Header `boost/outbuf/string.hpp`]
/To-do/
[endsect]

[section Header `boost/outbuf/FILE.hpp`]
/To-do/
[endsect]

[section Header `boost/outbuf/streambuf.hpp`]
/To-do/
[endsect]


[endsect]