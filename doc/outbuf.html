<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.5">
<title>Outbuf</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | http://asciidoctor.org */
/* Remove comment around @import statement below when using as a custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary{display:block}
audio,canvas,video{display:inline-block}
audio:not([controls]){display:none;height:0}
[hidden],template{display:none}
script{display:none!important}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
a{background:transparent}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
input[type="search"]{-webkit-appearance:textfield;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;box-sizing:content-box}
input[type="search"]::-webkit-search-cancel-button,input[type="search"]::-webkit-search-decoration{-webkit-appearance:none}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*:before,*:after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.center{margin-left:auto;margin-right:auto}
.spread{width:100%}
p.lead,.paragraph.lead>p,#preamble>.sectionbody>.paragraph:first-of-type p{font-size:1.21875em;line-height:1.6}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:none}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #ddddd8;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol,ul.no-bullet,ol.no-bullet{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ul.no-bullet{list-style:none}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite:before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media only screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7;font-weight:bold}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt,table tr:nth-of-type(even){background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix:before,.clearfix:after,.float-group:before,.float-group:after{content:" ";display:table}
.clearfix:after,.float-group:after{clear:both}
*:not(pre)>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background-color:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed;word-wrap:break-word}
*:not(pre)>code.nobreak{word-wrap:normal}
*:not(pre)>code.nowrap{white-space:nowrap}
pre,pre>code{line-height:1.45;color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;text-rendering:optimizeSpeed}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background-color:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menu{color:rgba(0,0,0,.8)}
b.button:before,b.button:after{position:relative;top:-1px;font-weight:400}
b.button:before{content:"[";padding:0 3px 0 2px}
b.button:after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header:before,#header:after,#content:before,#content:after,#footnotes:before,#footnotes:after,#footer:before,#footer:after{content:" ";display:table}
#header:after,#content:after,#footnotes:after,#footer:after{clear:both}
#content{margin-top:1.25em}
#content:before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #ddddd8}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #ddddd8;padding-bottom:8px}
#header .details{border-bottom:1px solid #ddddd8;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span:before{content:"\00a0\2013\00a0"}
#header .details br+span.author:before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark:before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber:after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #ddddd8;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #efefed;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media only screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background-color:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #efefed;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #efefed;left:auto;right:0}}
@media only screen and (min-width:1280px){body.toc2{padding-left:26em;padding-right:0}
#toc.toc2{width:26em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:26em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background-color:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
.sect1{padding-bottom:.625em}
@media only screen and (min-width:768px){.sect1{padding-bottom:1.25em}}
.sect1+.sect1{border-top:1px solid #efefed}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor:before,h2>a.anchor:before,h3>a.anchor:before,#toctitle>a.anchor:before,.sidebarblock>.content>.title>a.anchor:before,h4>a.anchor:before,h5>a.anchor:before,h6>a.anchor:before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock>caption.title{white-space:nowrap;overflow:visible;max-width:0}
.paragraph.lead>p,#preamble>.sectionbody>.paragraph:first-of-type p{color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>.paragraph:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #ddddd8;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock pre:not(.highlight),.listingblock pre[class="highlight"],.listingblock pre[class^="highlight "],.listingblock pre.CodeRay,.listingblock pre.prettyprint{background:#f7f7f8}
.sidebarblock .literalblock pre,.sidebarblock .listingblock pre:not(.highlight),.sidebarblock .listingblock pre[class="highlight"],.sidebarblock .listingblock pre[class^="highlight "],.sidebarblock .listingblock pre.CodeRay,.sidebarblock .listingblock pre.prettyprint{background:#f2f1f1}
.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;padding:1em;font-size:.8125em}
.literalblock pre.nowrap,.literalblock pre[class].nowrap,.listingblock pre.nowrap,.listingblock pre[class].nowrap{overflow-x:auto;white-space:pre;word-wrap:normal}
@media only screen and (min-width:768px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:.90625em}}
@media only screen and (min-width:1280px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:1em}}
.literalblock.output pre{color:#f7f7f8;background-color:rgba(0,0,0,.9)}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.listingblock>.content{position:relative}
.listingblock code[data-lang]:before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:#999}
.listingblock:hover code[data-lang]:before{display:block}
.listingblock.terminal pre .command:before{content:attr(data-prompt);padding-right:.5em;color:#999}
.listingblock.terminal pre .command:not([data-prompt]):before{content:"$"}
table.pyhltable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.pyhltable td{vertical-align:top;padding-top:0;padding-bottom:0;line-height:1.45}
table.pyhltable td.code{padding-left:.75em;padding-right:0}
pre.pygments .lineno,table.pyhltable td:not(.code){color:#999;padding-left:0;padding-right:.5em;border-right:1px solid #ddddd8}
pre.pygments .lineno{display:inline-block;margin-right:.25em}
table.pyhltable .linenodiv{background:none!important;padding-right:0!important}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock blockquote p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote:before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.5em;margin-right:.5ex;text-align:right}
.quoteblock .quoteblock{margin-left:0;margin-right:0;padding:.5em 0;border-left:3px solid rgba(0,0,0,.6)}
.quoteblock .quoteblock blockquote{padding:0 0 0 .75em}
.quoteblock .quoteblock blockquote:before{display:none}
.verseblock{margin:0 1em 1.25em 1em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract{margin:0 0 1.25em 0;display:block}
.quoteblock.abstract blockquote,.quoteblock.abstract blockquote p{text-align:left;word-spacing:0}
.quoteblock.abstract blockquote:before,.quoteblock.abstract blockquote p:first-of-type:before{display:none}
table.tableblock{max-width:100%;border-collapse:separate}
table.tableblock td>.paragraph:last-child p>p:last-child,table.tableblock th>p:last-child,table.tableblock td>p:last-child{margin-bottom:0}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all th.tableblock,table.grid-all td.tableblock{border-width:0 1px 1px 0}
table.grid-all tfoot>tr>th.tableblock,table.grid-all tfoot>tr>td.tableblock{border-width:1px 1px 0 0}
table.grid-cols th.tableblock,table.grid-cols td.tableblock{border-width:0 1px 0 0}
table.grid-all *>tr>.tableblock:last-child,table.grid-cols *>tr>.tableblock:last-child{border-right-width:0}
table.grid-rows th.tableblock,table.grid-rows td.tableblock{border-width:0 0 1px 0}
table.grid-all tbody>tr:last-child>th.tableblock,table.grid-all tbody>tr:last-child>td.tableblock,table.grid-all thead:last-child>tr>th.tableblock,table.grid-rows tbody>tr:last-child>th.tableblock,table.grid-rows tbody>tr:last-child>td.tableblock,table.grid-rows thead:last-child>tr>th.tableblock{border-bottom-width:0}
table.grid-rows tfoot>tr>th.tableblock,table.grid-rows tfoot>tr>td.tableblock{border-width:1px 0 0 0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot{border-width:1px 0}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
td>div.verse{white-space:pre}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.unstyled,ol.unnumbered,ul.checklist,ul.none{list-style-type:none}
ul.unstyled,ol.unnumbered,ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1em;font-size:.85em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{width:1em;position:relative;top:1px}
ul.inline{margin:0 auto .625em auto;margin-left:-1.375em;margin-right:0;padding:0;list-style:none;overflow:hidden}
ul.inline>li{list-style:none;float:left;margin-left:1.375em;display:block}
ul.inline>li>*{display:block}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist>table tr>td:first-of-type{padding:0 .75em;line-height:1}
.colist>table tr>td:last-of-type{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left,.imageblock[style*="float: left"]{margin:.25em .625em 1.25em 0}
.imageblock.right,.imageblock[style*="float: right"]{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em 0;border-width:1px 0 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;text-indent:-1.05em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background-color:#00fafa}
.black{color:#000}
.black-background{background-color:#000}
.blue{color:#0000bf}
.blue-background{background-color:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background-color:#fa00fa}
.gray{color:#606060}
.gray-background{background-color:#7d7d7d}
.green{color:#006000}
.green-background{background-color:#007d00}
.lime{color:#00bf00}
.lime-background{background-color:#00fa00}
.maroon{color:#600000}
.maroon-background{background-color:#7d0000}
.navy{color:#000060}
.navy-background{background-color:#00007d}
.olive{color:#606000}
.olive-background{background-color:#7d7d00}
.purple{color:#600060}
.purple-background{background-color:#7d007d}
.red{color:#bf0000}
.red-background{background-color:#fa0000}
.silver{color:#909090}
.silver-background{background-color:#bcbcbc}
.teal{color:#006060}
.teal-background{background-color:#007d7d}
.white{color:#bfbfbf}
.white-background{background-color:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background-color:#fafa00}
span.icon>.fa{cursor:default}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note:before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip:before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning:before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution:before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important:before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background-color:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]:after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background-color:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@media print{@page{margin:1.25cm .75cm}
*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare):after,a[href^="https:"]:not(.bare):after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]:after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #ddddd8!important;padding-bottom:0!important}
.sect1{padding-bottom:0!important}
.sect1+.sect1{border:0!important}
#header>h1:first-child{margin-top:1.25rem}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em 0}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span:before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]:before{display:block}
#footer{background:none!important;padding:0 .9375em}
#footer-text{color:rgba(0,0,0,.6)!important;font-size:.9em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
</style>
</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>Outbuf</h1>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_overview">1. Overview</a>
<ul class="sectlevel2">
<li><a href="#_rationale">1.1. Rationale</a></li>
<li><a href="#_how_to_write_into_an_outbuf_object">1.2. How to write into an outbuf object</a>
<ul class="sectlevel3">
<li><a href="#_low_level_writing">1.2.1. Low-level writing</a></li>
<li><a href="#_the_code_write_code_and_code_put_code_function_templates">1.2.2. The <code>write</code> and <code>put</code> function templates</a></li>
<li><a href="#_inserting_formatted_data">1.2.3. Inserting formatted data</a></li>
</ul>
</li>
<li><a href="#_the_code_basic_outbuf_noexcept_code_class_template">1.3. The <code>basic_outbuf_noexcept</code> class template</a></li>
<li><a href="#_the_code_underlying_outbuf_code_class_template">1.4. The <code>underlying_outbuf</code> class template</a></li>
</ul>
</li>
<li><a href="#_reference">2. Reference</a>
<ul class="sectlevel2">
<li><a href="#_header_code_boost_outbuf_hpp_code">2.1. Header <code>boost/outbuf.hpp</code></a>
<ul class="sectlevel3">
<li><a href="#min_size_after_recycle">2.1.1. <code>min_size_after_recycle</code></a></li>
<li><a href="#__code_underlying_outbuf_code">2.1.2. <code>underlying_outbuf</code></a></li>
<li><a href="#__code_basic_outbuf_code">2.1.3. <code>basic_outbuf</code></a></li>
<li><a href="#__code_basic_outbuf_noexcept_code">2.1.4. <code>basic_outbuf_noexcept</code></a></li>
<li><a href="#_garbage_buffer">2.1.5. Garbage buffer</a></li>
<li><a href="#__code_basic_cstr_writer_code">2.1.6. <code>basic_cstr_writer</code></a></li>
<li><a href="#__code_discarded_outbuf_code">2.1.7. <code>discarded_outbuf</code></a></li>
</ul>
</li>
<li><a href="#_header_code_boost_outbuf_iterator_hpp_code">2.2. Header <code>boost/outbuf/iterator.hpp</code></a>
<ul class="sectlevel3">
<li><a href="#__code_underlying_outbuf_iterator_code">2.2.1. <code>underlying_outbuf_iterator</code></a></li>
<li><a href="#outbuf_iterator">2.2.2. <code>outbuf_iterator</code></a></li>
</ul>
</li>
<li><a href="#_header_code_boost_outbuf_string_hpp_code">2.3. Header <code>boost/outbuf/string.hpp</code></a>
<ul class="sectlevel3">
<li><a href="#__code_basic_string_maker_code">2.3.1. <code>basic_string_maker</code></a></li>
<li><a href="#__code_basic_string_maker_noexcept_code">2.3.2. <code>basic_string_maker_noexcept</code></a></li>
<li><a href="#__code_basic_string_appender_code">2.3.3. <code>basic_string_appender</code></a></li>
<li><a href="#__code_basic_string_appender_noexcept_code">2.3.4. <code>basic_string_appender_noexcept</code></a></li>
</ul>
</li>
<li><a href="#_header_code_boost_outbuf_streambuf_hpp_code">2.4. Header <code>boost/outbuf/streambuf.hpp</code></a>
<ul class="sectlevel3">
<li><a href="#__code_basic_streambuf_writer_code">2.4.1. <code>basic_streambuf_writer</code></a></li>
</ul>
</li>
<li><a href="#_header_code_boost_outbuf_cfile_hpp_code">2.5. Header <code>boost/outbuf/cfile.hpp</code></a>
<ul class="sectlevel3">
<li><a href="#__code_narrow_cfile_writer_code">2.5.1. <code>narrow_cfile_writer</code></a></li>
<li><a href="#__code_wide_cfile_writer_code">2.5.2. <code>wide_cfile_writer</code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>The <code>basic_outbuf</code> abstract class template provides a thin,
simple and lightweight abstraction over output streams
that can be used in
<a href="https://en.cppreference.com/w/cpp/freestanding">freestanding</a>
C++ implementations.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
This library does not belong to the <a href="https://www.boost.org/">Boost C++ libraries</a>.
      Maybe some day it will be there.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_overview">1. Overview</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_rationale">1.1. Rationale</h3>
<div class="paragraph">
<p>Suppose you want to implement an encoder. Let&#8217;s say to Base64.
That should be a simple task, right? But it turns out that is
hard to find the ideal design. Let&#8217;s consider a function that
returns a string object:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">std::string to_base64(const std::byte* src, std::size_t count);</code></pre>
</div>
</div>
<div class="paragraph">
<p>It&#8217;s simple and easy to use. But it has an extra cost of a heap
allocation, which some users may dislike.</p>
</div>
<div class="paragraph">
<p>An alternative is to use <code>std::ostream</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">void to_base64(std::ostream&amp; dest, const std::byte* src, std::size_t count);</code></pre>
</div>
</div>
<div class="paragraph">
<p>However such function is complex to use. The user needs to implement
a class that derives from <code>ostream</code> to customize the
destination. It&#8217;s a complex task for most C++ programmers.</p>
</div>
<div class="paragraph">
<p>Also, <code>std::ostream</code> and <code>std::string</code> are not available
in freestanding C++ implementations. Thus they should be avoided
if you want your function to usable in the widest range of
environments.</p>
</div>
<div class="paragraph">
<p>So, you may think, let&#8217;s adopt the C-style:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">bool to_base64( char** dest
              , char* dest_end
              , const std::byte** src
              , const std::byte* src_end );</code></pre>
</div>
</div>
<div class="paragraph">
<p>This way the user would need to successively call <code>to_base64</code>
until the whole input is read. Besides the inconvenience,
this still has a important limitation: sometimes the input is not
available as an array of bytes. Sometimes it is lazyly avaluated.
For example, suppose you have a class <code>Image</code> that has member
functions that encodes to different image formats:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">class Image
{
public:
    // ...

    /* ??? */ to_jpeg( /* ??? */ ) const;
    /* ??? */ to_bmp( /* ??? */ ) const;
    /* ??? */ to_png( /* ??? */ ) const;
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now how do you design the all these functions, such
that one could convert an image to JPEG, and then to
Base64? What signatures should they have ?</p>
</div>
<div class="paragraph">
<p>The <code>basic_outbuf</code> abstract class template aims to solve the puzzle.
Now you can declare <code>to_jpeg</code> like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">    void to_jpeg(boost::basic_outbuf&lt;std::byte&gt;&amp; dest) const;</code></pre>
</div>
</div>
<div class="paragraph">
<p>And, instead of a function, you can design the Base64 encoder as
a class that derives from <code>basic_outbuf</code> and that would
hold a reference to another <code>basic_outbuf</code> as the further
destination.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">Image image;
// edit the image ...

// encode the image:
Base64Encoder base64encoder{some_destination};
image.to_jpeg(base64encoder);
encoder64encoder.finish();</code></pre>
</div>
</div>
<div class="paragraph">
<p>With the same pattern you could design, for instance,
an encrypter. So you can convert the image to JPEG,
then encrypt it, then convert to it Base64, then insert
it into some a JSON output, then send it to &#8230;&#8203; whatever.
You got the idea: composability, free of heap allocation
and support to lazy evaluation. All this with a
simple class template defined in ligthweight to compile
header file, and that can be used in a
freestanding implementation.</p>
</div>
</div>
<div class="sect2">
<h3 id="_how_to_write_into_an_outbuf_object">1.2. How to write into an outbuf object</h3>
<div class="sect3">
<h4 id="_low_level_writing">1.2.1. Low-level writing</h4>
<div class="paragraph">
<p>The member functions <a href="#basic_outbuf_pos"><code>pos()</code></a> and
<a href="#basic_outbuf_end"><code>end()</code></a> define the
memory region where you can write. If the space is
too small, you can call the <a href="#underlying_outbuf_recycle"><code>recycle</code></a>
virtual function. It will consume the content written so far
since the last call and reset the buffer positions.
<code>recycle()</code> ensures that the new space afterwards is at
least equal to <code><a href="#min_size_after_recycle"><code>min_size_after_recycle</code></a>&lt;char_type&gt;()</code>,
which is at least equal to 64. If you need more space than
that, then you have to find a way to break your content
down into smaller parts or you have to use an intermediate
buffer.</p>
</div>
<div class="paragraph">
<p>After you write anything to
<code>pos()</code> you need to call <code>advance</code> or <code>advance_to</code>.
They cause the value returned by <code>pos()</code> to be
incremented.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">#include &lt;boost/outbut.hpp&gt;

void get_message(boost::basic_outbuf&lt;char&gt;&amp; dest)
{
    if (dest.end() - dest.pos() &lt; 5)
    {
        dest.recycle();
    }
    std::strcpy(dest.pos(), "Hello");
    dest.advance(5);
    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The code above can be rewriten like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">#include &lt;boost/outbut.hpp&gt;

void get_message(boost::basic_outbuf&lt;char&gt;&amp; dest)
{
    dest.require(5);
    std::strcpy(dest.pos(), "Hello");
    dest.advance(5);
    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>dest.require(s)</code> does just that: it calls <code>recycle</code> if the
the available buffer&#8217;s space is less than <code>s</code>.</p>
</div>
<div class="paragraph">
<p>The range [<code>pos()</code>, <code>end()</code>) is always a valid accessible memory area.
So it is always safe to write things there.
However, you should occasionally check whether the outbuf
is in "good" state. You do that with the <a href="#underlying_outbuf_good"><code>good</code></a>
member function. If it returns <code>false</code>, then it means that writing
into the buffer has no relevant side effect and it&#8217;s a mere waste
of CPU resources. The state may change from good to bad when <code>recycle</code>
is called. It never changes from bad to good.</p>
</div>
</div>
<div class="sect3">
<h4 id="_the_code_write_code_and_code_put_code_function_templates">1.2.2. The <code>write</code> and <code>put</code> function templates</h4>
<div class="paragraph">
<p>If you want to write an array of characters, you can use the
<a href="#basic_outbuf_write"><code>write</code></a> function template, that writes it
in a piecewise way, taking care to never write beyond the buffer&#8217;s
end and calling <code>recycle()</code> whenever necessary.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">boost::basic_outbuf&lt;char&gt; ob&amp; = /* ... */;
string_view str = /* ... */;
boost::write(ob, str.begin(), str.end());</code></pre>
</div>
</div>
<div class="paragraph">
<p>See also the <a href="#basic_outbuf_put"><code>put</code></a> function template
that inserts a single character.</p>
</div>
</div>
<div class="sect3">
<h4 id="_inserting_formatted_data">1.2.3. Inserting formatted data</h4>
<div class="paragraph">
<p><code>basic_outbuf</code> does not support formatting. But since you have direct
access to the buffer, you could use <code>std::to_chars</code> and <code>std::sprintf</code>
though that would require from you to constantly check whether the buffer&#8217;s
size is adequate.</p>
</div>
<div class="paragraph">
<p>However if can use <a href="https://fmt.dev/latest/index.html">{fmt}</a>
( or <a href="http://open-std.org/JTC1/SC22/WG21/docs/papers/2019/p0645r10.html">&lt;format&gt;</a>
  , available in C++20 ), you can insert
formatted data through an output iterator adapter:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">#include &lt;boost/outbuf/iterator.hpp&gt;
#include &lt;fmt/format.h&gt;

int sample(boost::basic_outbuf&lt;char&gt;&amp; ob) {
    boost::outbuf_iterator&lt;char&gt; it{ob};
    fmt::format_to(it, "ten = {}, and twenty = {}.", 10, 20)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#outbuf_iterator"><code>outbuf_iterator</code></a> calls <code>recycle()</code> whenever
is necessary, so that you don&#8217;t need to constantly check the
buffer&#8217;s available space.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_the_code_basic_outbuf_noexcept_code_class_template">1.3. The <code>basic_outbuf_noexcept</code> class template</h3>
<div class="paragraph">
<p>The <a href="#basic_outbuf_noexcept"><code>basic_outbuf_noexcept</code></a>
class template derives from <code>basic_outbuf</code>, and it has
the exact same members. The only difference is that
<code>basic_outbuf_noexcept&lt;CharT&gt;::recycle()</code> is noexcept.</p>
</div>
<div class="paragraph">
<p>Consider a function that takes a <code>basic_outbuf</code>
reference as paramenter an forwards it to another module.
Sometimes we can&#8217;t allow exceptions crossing
modules' boundaries. So that&#8217;s an example of when a
one rather use <code>basic_outbuf_noexcept</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_the_code_underlying_outbuf_code_class_template">1.4. The <code>underlying_outbuf</code> class template</h3>
<div class="paragraph">
<p><code>basic_outbuf&lt;CharT&gt;</code> derives from
<a href="#underlying_outbuf"><code>underlying_outbuf&lt;sizeof(CharT)&gt;</code></a>.
The inheritance is private to force you to call
<code>as_underlying()</code> member function to cast an
<code>basic_outbuf</code> reference to <code>underlying_outbuf</code>,
because it&#8217;s good to prevent implicit cast in this
case.</p>
</div>
<div class="paragraph">
<p>To understand the purpose of <code>underlying_outbuf</code>, suppose you
want to implement a function that converts UTF-32 to UTF-8,
and, of course, you want to use <code>basic_outbuf</code> to handle the output.
Now, there are different character type that can represent
UTF-8: <code>char</code>, <code>char8_t</code>, <code>std::byte</code>, <code>unsigned char</code> &#8230;&#8203;
So you face dilemma of which one to adopt:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">void utf32_to_utf8( boost::outbuf::basic_outbuf&lt;/* ??? */&gt;&amp; destination
                  , const char32_t* src
                  , std::size_t src_size );</code></pre>
</div>
</div>
<div class="paragraph">
<p>Actually, the caller should ideally decide that.
So you may consider implement <code>utf32_to_utf8</code> as template:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">template &lt;typename CharT&gt;
void utf32_to_utf8( boost::outbuf::basic_outbuf&lt;CharT&gt;&amp; destination
                  , const char32_t* src
                  , std::size_t src_size );</code></pre>
</div>
</div>
<div class="paragraph">
<p>But templates have their disadvantages, and sometimes we want
or need to avoid them.
That&#8217;s the reason the <code>underlying_outbuf</code> class template exists.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">void utf32_to_utf8( boost::outbuf::underlying_outbuf&lt;1&gt;&amp; destination
                  , const char32_t* src
                  , std::size_t src_size );</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now the caller can pass any <code>basic_outbuf&lt;CharT&gt;</code>,
as long as <code>sizeof(CharT)</code> is <code>1</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">const char32_t* src             = /*...*/;
std::size_t src_size            = /*...*/;
boost::basic_outbuf&lt;char&gt;&amp; dest = /*...*/;

utf32_to_utf8(dest.as_underlying(), src, src_size);</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_reference">2. Reference</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_header_code_boost_outbuf_hpp_code">2.1. Header <code>boost/outbuf.hpp</code></h3>
<div class="sect3">
<h4 id="min_size_after_recycle">2.1.1. <code>min_size_after_recycle</code></h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">template &lt;typename CharT&gt;
constexpr std::size_t min_size_after_recycle();</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p>Implementation-defined value greater than or equal to 64.</p>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="__code_underlying_outbuf_code">2.1.2. <code>underlying_outbuf</code></h4>
<div class="sect4">
<h5 id="_synopsis">Synopsis</h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">namespace boost {

template &lt;std::size_t CharSize&gt;
class underlying_outbuf;
{
public:

    using char_type = /*see below*/;

    underlying_outbuf(const underlying_outbuf&amp;) = delete;
    underlying_outbuf(underlying_outbuf&amp;&amp;) = delete;
    underlying_outbuf&amp; operator=(const underlying_outbuf&amp;) = delete;
    underlying_outbuf&amp; operator=(underlying_outbuf&amp;&amp;) = delete;

    virtual ~underlying_outbuf() = default;

    char_type* pos() const noexcept;
    char_type* end() const noexcept;
    std::size_t size() const noexcept;
    bool good() const noexcept;
    void advance_to(char_type* p);
    void advance(std::size_t n);
    void require(std::size_t s);

    virtual bool recycle() = 0;

protected:

    underlying_outbuf(char_type* pos_, char_type* end_);

    underlying_outbuf(char_type* pos_, std::size_t n);

    void set_pos(char_type* p) noexcept;
    void set_end(char_type* e) noexcept;
    void set_good(true g) noexcept;
};

// global type aliases

template &lt;std::size_t CharSize&gt;
using underlying_outbuf_char_type = typename underlying_outbuf&lt;CharSize&gt;::char_type

// global functions

template &lt;std::size_t CharSize&gt;
void write( boost::underlying_outbuf&lt;CharSize&gt;&amp; ob
          , const boost::underlying_outbuf_char_type&lt;CharSize&gt;* data
          , std::size_t data_size );

template &lt;std::size_t CharSize&gt;
void write( boost::underlying_outbuf&lt;CharSize&gt;&amp; ob
          , const boost::underlying_outbuf_char_type&lt;CharSize&gt;* data
          , const boost::underlying_outbuf_char_type&lt;CharSize&gt;* data_end );

template &lt;std::size_t CharSize&gt;
void put( boost::underlying_outbuf&lt;CharSize&gt;&amp; ob
        , boost::underlying_outbuf_char_type&lt;CharSize&gt; ch );

} // namespace boost</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_member_types">Member types</h5>
<div id="underlying_outbuf_char_type" class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">using char_type = /*see below*/;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Equal to
</td>
<td class="hdlist2">
<div class="ulist">
<ul>
<li>
<p><code>std::uint8_t</code> if <code>CharSize == 1</code></p>
</li>
<li>
<p><code>char16_t</code> if <code>CharSize == 2</code></p>
</li>
<li>
<p><code>char32_t</code> if <code>CharSize == 4</code></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>It is undefined for any other <code>CharSize</code> value.</p>
</div>
</div>
<div class="sect4">
<h5 id="_public_member_functions">Public member functions</h5>
<div id="underlying_outbuf_pos" class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">char_type* pos() const noxcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return
</td>
<td class="hdlist2">
<p>The memory position where the content shall be written.</p>
</td>
</tr>
</table>
</div>
<div id="underlying_outbuf_end" class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">char_type* end() const noxcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return
</td>
<td class="hdlist2">
<p>The end of memory position where the content shall be written.
Dereferencing <code>end()</code> has undefined behaviour.</p>
</td>
</tr>
</table>
</div>
<div id="underlying_outbuf_size" class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">std::size_t size() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return
</td>
<td class="hdlist2">
<p><code>end() - pos()</code></p>
</td>
</tr>
</table>
</div>
<div id="underlying_outbuf_recycle" class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">virtual void recycle() = 0;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Posconditions
</td>
<td class="hdlist2">
<div class="ulist">
<ul>
<li>
<p><code>size() &gt;= <a href="#min_size_after_recycle"><code>min_size_after_recycle</code></a>&lt;char_type&gt;()</code></p>
</li>
<li>
<p>The range [ <code>pos()</code>, <code>end()</code> ) is valid accessible memory area</p>
</li>
<li>
<p>If the return value of <code>good()</code> was <code>false</code> before this call to <code>recycle()</code>, then <code>good()</code> remains returning <code>false</code>.</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div id="underlying_outbuf_require" class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">void require(std::size_t s)</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>Calls <code>recycle()</code> if <code>size() &lt; s</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Precondition
</td>
<td class="hdlist2">
<p><code>s &lt;= min_size_after_recycle&lt;char_type&gt;()</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Postcondition
</td>
<td class="hdlist2">
<p><code>size() &gt;= s</code></p>
</td>
</tr>
</table>
</div>
<div id="underlying_outbuf_advance_to" class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">void advance_to(char_type* p)</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>Advance the buffer&#8217;s position to <code>p</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Precondition
</td>
<td class="hdlist2">
<p><code>pos() &lt;= p &amp;&amp; p &lt;= end()</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Postcondition
</td>
<td class="hdlist2">
<p><code>pos() == p</code></p>
</td>
</tr>
</table>
</div>
<div id="underlying_outbuf_advance_count" class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">void advance(std::size_t n)</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>Same as <code>advance_to(pos() + n)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Precondition
</td>
<td class="hdlist2">
<p><code>n &lt;= size()</code></p>
</td>
</tr>
</table>
</div>
<div id="underlying_outbuf_advance" class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">void advance()</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>Same as <code>advance_to(1)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Precondition
</td>
<td class="hdlist2">
<p><code>pos() != end()</code></p>
</td>
</tr>
</table>
</div>
<div id="underlying_outbuf_good" class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">bool good() const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return
</td>
<td class="hdlist2">
<p>The state of this object. If the return value is <code>false</code>,
then it means that calling <code>advance</code> of <code>advance_to</code> has no
relevant side effect because the content written in the buffer
will not be read anymore.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Note
</td>
<td class="hdlist2">
<p>The range [ <code>pos()</code>, <code>end()</code> ) shall aways be a valid
accessible memory, even when <code>good()</code> returns <code>false</code>.</p>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_protected_member_functions">Protected Member functions</h5>
<div id="underlying_outbuf_ctor_range" class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">underlying_outbuf(CharT* pos_, CharT* end_)</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Preconditions
</td>
<td class="hdlist2">
<div class="ulist">
<ul>
<li>
<p><code>pos_ &lt;= end_</code></p>
</li>
<li>
<p>The range [ <code>pos_</code>, <code>end_</code> ) must be an accessible memory area.</p>
</li>
</ul>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Posconditions
</td>
<td class="hdlist2">
<div class="ulist">
<ul>
<li>
<p><code>pos() == pos_</code></p>
</li>
<li>
<p><code>end() == end_</code></p>
</li>
<li>
<p><code>good() == true</code></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div id="underlying_outbuf_ctor_count" class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">underlying_outbuf(CharT* pos_, std::size_t n)</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Preconditions
</td>
<td class="hdlist2">
<div class="ulist">
<ul>
<li>
<p>The range [ <code>pos_</code>, `pos_ + n ` ) must be an accessible memory area.</p>
</li>
</ul>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Posconditions
</td>
<td class="hdlist2">
<div class="ulist">
<ul>
<li>
<p><code>pos() == pos_</code></p>
</li>
<li>
<p><code>end() == pos_ + n</code></p>
</li>
<li>
<p><code>good() == true</code></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div id="underlying_outbuf_set_pos" class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">void set_pos(CharT* p) noexcept</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions
</td>
<td class="hdlist2">
<p><code>pos() == p</code></p>
</td>
</tr>
</table>
</div>
<div id="underlying_outbuf_set_end" class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">void set_end(CharT* e) noexcept</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions
</td>
<td class="hdlist2">
<p><code>end() == e</code></p>
</td>
</tr>
</table>
</div>
<div id="underlying_outbuf_set_good" class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">void set_good(bool g) noexcept</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions
</td>
<td class="hdlist2">
<p><code>good() == g</code></p>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_global_functions">Global functions</h5>
<div id="underlying_outbuf_put" class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">template &lt;std::size_t CharSize&gt;
void put( boost::underlying_outbuf&lt;CharSize&gt;&amp; ob
        , boost::underlying_outbuf_char_type&lt;CharSize&gt; ch );</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>Same as:</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">if (ob.size() == 0) {
    ob.recycle();
}
*ob.pos() = ch;
ob.advance();</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div id="underlying_outbuf_write_range" class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">template &lt;std::size_t CharSize&gt;
void write( boost::underlying_outbuf&lt;CharSize&gt;&amp; ob
          , const boost::underlying_outbuf_char_type&lt;CharSize&gt;* data
          , const boost::underlying_outbuf_char_type&lt;CharSize&gt;* data_end );</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>Writes the the range [ <code>data</code>, <code>data_end</code> ) into <code>ob</code>, calling <code>ob.recycle()</code>
how many times are necessary.</p>
</td>
</tr>
</table>
</div>
<div id="underlying_outbuf_write_count" class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">template &lt;std::size_t CharSize&gt;
void write( boost::underlying_outbuf&lt;CharSize&gt;&amp; ob
          , const boost::underlying_outbuf_char_type&lt;CharSize&gt;* data
          , std::size_t data_size );</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>Same as <code>write(ob, data, data + data_size)</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="__code_basic_outbuf_code">2.1.3. <code>basic_outbuf</code></h4>
<div class="sect4">
<h5 id="_synopsis_2">Synopsis</h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">namespace boost {

template &lt;typename CharT&gt;
class basic_outbuf: private underlying_outbuf&lt;sizeof(CharT)&gt;
{
public:
    using char_type = CharT;
    basic_outbuf(const basic_outbuf&amp;) = delete;
    basic_outbuf(basic_outbuf&amp;&amp;) = delete;
    basic_outbuf&amp; operator=(const basic_outbuf&amp;) = delete;
    basic_outbuf&amp; operator=(basic_outbuf&amp;&amp;) = delete;

    virtual ~basic_outbuf() = default;

    underlying_outbuf&lt;sizeof(CharT)&gt;&amp; as_underlying() noexcept;
    const underlying_outbuf&lt;sizeof(CharT)&gt;&amp; as_underlying() const noexcept;

    char_type* pos() const noexcept;
    char_type* end() const noexcept;
    void advance_to(char_type* p);

    using underlying_outbuf&lt;sizeof(CharT)&gt;::size;
    using underlying_outbuf&lt;sizeof(CharT)&gt;::advance;
    using underlying_outbuf&lt;sizeof(CharT)&gt;::good;
    using underlying_outbuf&lt;sizeof(CharT)&gt;::require;
    using underlying_outbuf&lt;sizeof(CharT)&gt;::recycle;

protected:

    basic_outbuf(char_type* pos_, char_type* end_);
    basic_outbuf(char_type* pos_, std::size_t n);

    void set_pos(char_type* p) noexcept;
    void set_end(char_type* e) noexcept;

    using underlying_outbuf&lt;sizeof(CharT)&gt;::set_good;
};

// global type aliases

using outbuf      = basic_outbuf&lt;char&gt;;
using u8outbuf    = basic_outbuf&lt;char8_t&gt;;
using u16outbuf   = basic_outbuf&lt;char16_t&gt;;
using u32outbuf   = basic_outbuf&lt;char32_t&gt;;
using woutbuf     = basic_outbuf&lt;wchar_t&gt;;
using bin_outbuf  = basic_outbuf&lt;std::byte&gt;;

// global functions

template &lt;typename CharT&gt;
void write( boost::basic_outbuf&lt;CharT&gt;&amp; ob
          , const CharT* data
          , std::size_t count );

template &lt;typename CharT&gt;
void write( boost::basic_outbuf&lt;CharT&gt;&amp; ob
          , const CharT* data
          , const CharT* data_end );

void write(boost::basic_outbuf&lt;char&gt;&amp; ob, const char* cstr);

void write(boost::basic_outbuf&lt;wchar_t&gt;&amp; ob, const wchar_t* cstr);

template &lt;typename CharT&gt;
void put(boost::basic_outbuf&lt;CharT&gt;&amp; ob, CharT ch);

} // namespace boost</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_public_member_functions_2">Public member functions</h5>
<div id="basic_outbuf_as_underlying" class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">underlying_outbuf&lt;sizeof(CharT)&gt;&amp; as_underlying() noexcept;
const underlying_outbuf&lt;sizeof(CharT)&gt;&amp; as_underlying() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return
</td>
<td class="hdlist2">
<p><code>*this</code></p>
</td>
</tr>
</table>
</div>
<div id="basic_outbuf_pos" class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">char_type* pos() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return
</td>
<td class="hdlist2">
<p><code>(CharT*) as_underlying().pos();</code></p>
</td>
</tr>
</table>
</div>
<div id="basic_outbuf_end" class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">char_type* end() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return
</td>
<td class="hdlist2">
<p><code>(CharT*) as_underlying().end();</code></p>
</td>
</tr>
</table>
</div>
<div id="basic_outbuf_advance_to" class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">void advance_to(char_type* p);</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>Same as</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">as_underlying().advance_to((underlying_outbuf_char_type&lt;sizeof(CharT)&gt;*)p)</code></pre>
</div>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Precondition
</td>
<td class="hdlist2">
<p><code>p &lt;= end()</code></p>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_public_member_functions_inherited_from_private_base_code_underlying_outbuf_sizeof_chart_code">Public member functions inherited from private base <code>underlying_outbuf&lt;sizeof(CharT)&gt;</code></h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">    using underlying_outbuf&lt;sizeof(CharT)&gt;::size;
    using underlying_outbuf&lt;sizeof(CharT)&gt;::advance;
    using underlying_outbuf&lt;sizeof(CharT)&gt;::good;
    using underlying_outbuf&lt;sizeof(CharT)&gt;::require;
    using underlying_outbuf&lt;sizeof(CharT)&gt;::recycle;</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_protected_member_functions_2">Protected member functions</h5>
<div id="basic_outbuf_ctor_range" class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">basic_outbuf(char_type* pos_, char_type* end_);</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>Initializes private base class <code>underlying_outbuf&lt;sizeof(CharT)&gt;</code>
with <code>pos_</code> and <code>end_</code> casted as <code>underlying_outbuf_char_type&lt;sizeof(CharT)&gt;*</code>.</p>
</td>
</tr>
</table>
</div>
<div id="basic_outbuf_ctor_count" class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">basic_outbuf(char_type* pos_, std::size_t n);</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>Same as <code>basic_outbuf(pos_, pos + n)</code></p>
</td>
</tr>
</table>
</div>
<div id="basic_outbuf_" class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">void set_pos(char_type* p) noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>Same as</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">as_underlying().set_pos((underlying_outbuf_char_type&lt;sizeof(CharT)&gt;*)p)</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div id="basic_outbuf_" class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">void set_end(char_type* e) noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>Same as</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">as_underlying().set_end((underlying_outbuf_char_type&lt;sizeof(CharT)&gt;*)e)</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div id="basic_outbuf_set_good" class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">void set_good(bool g) noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>Same as <code>as_underlying().set_good(g)</code></p>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_global_functions_2">Global functions</h5>
<div id="basic_outbuf_put" class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">template &lt;typename CharT&gt;
void put(boost::basic_outbuf&lt;CharT&gt;&amp; ob, CharT ch);</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>Same as:</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">if (ob.size() == 0) {
    ob.recycle();
}
*ob.pos() = ch;
ob.advance();</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div id="basic_outbuf_write_range" class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">template &lt;typename CharT&gt;
void write( boost::basic_outbuf&lt;CharT&gt;&amp; ob
          , const CharT* data
          , const CharT* data_end );</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>Writes the the range [ <code>data</code>, <code>data_end</code> ) into <code>ob</code>, calling <code>ob.recycle()</code>
how many times are necessary.</p>
</td>
</tr>
</table>
</div>
<div id="basic_outbuf_write_count" class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">template &lt;typename CharT&gt;
void write( boost::basic_outbuf&lt;CharT&gt;&amp; ob
          , const CharT* data
          , std::size_t data_size );</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>Same as <code>write(ob, data, data + data_size)</code></p>
</td>
</tr>
</table>
</div>
<div id="basic_outbuf_write_cstr" class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">void write( boost::basic_outbuf&lt;char&gt;&amp; ob
          , const char* cstr );</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>Same as <code>write(ob, cstr, std::strlen(cstr))</code></p>
</td>
</tr>
</table>
</div>
<div id="basic_outbuf_write_wcstr" class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">void write( boost::basic_outbuf&lt;wchar_t&gt;&amp; ob
          , const wchar_t* wcstr );</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>Same as <code>write(ob, wcstr, std::wstrlen(wcstr))</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="__code_basic_outbuf_noexcept_code">2.1.4. <code>basic_outbuf_noexcept</code></h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">namespace boost {

template &lt;typename CharT&gt;
class basic_outbuf_noexcept: public basic_outbuf&lt;CharT&gt;
{
public:

    virtual void recycle() noexcept = 0;

protected:

    using basic_outbuf&lt;CharT&gt;::basic_outbuf;
};

// type aliases

using outbuf_noexcept      = basic_outbuf_noexcept&lt;char&gt;;
using u8outbuf_noexcept    = basic_outbuf_noexcept&lt;char8_t&gt;;
using u16outbuf_noexcept   = basic_outbuf_noexcept&lt;char16_t&gt;;
using u32outbuf_noexcept   = basic_outbuf_noexcept&lt;char32_t&gt;;
using woutbuf_noexcept     = basic_outbuf_noexcept&lt;wchar_t&gt;;
using bin_outbuf_noexcept  = basic_outbuf_noexcept&lt;std::byte&gt;;

} // namespace boost</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_garbage_buffer">2.1.5. Garbage buffer</h4>
<div class="paragraph">
<p>These function templates return the begin and the end of a memory area that is never supposed to be read. It can be used when implementing a class that derives from <code>basic_outbuf</code> to set the buffer when the state is "bad".</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">template &lt;typename CharT&gt;
CharT* outbuf_garbage_buf();</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">template &lt;typename CharT&gt;
CharT* outbuf_garbage_buf_end();</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="__code_basic_cstr_writer_code">2.1.6. <code>basic_cstr_writer</code></h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">namespace boost {

template &lt;typename CharT&gt;
class basic_cstr_writer final: public boost::basic_outbuf_noexcept&lt;CharT&gt;
{
public:

    basic_cstr_writer(CharT* dest, CharT* dest_end);
    basic_cstr_writer(CharT* dest, std::size_t len);
    template &lt;std::size_t N&gt;
    basic_cstr_writer(CharT (&amp;dest)[N]);

    void recycle() noexcept override;
    struct result
    {
        CharT* ptr;
        bool truncated;
    };
    result finish();
};</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_public_member_function">Public member function</h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">basic_cstr_writer(CharT* dest, CharT* dest_end);</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Precondition
</td>
<td class="hdlist2">
<p><code>dest &lt; dest_end</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Postconditions
</td>
<td class="hdlist2">
<div class="ulist">
<ul>
<li>
<p><code>good() == true</code></p>
</li>
<li>
<p><code>pos() == dest</code></p>
</li>
<li>
<p><code>end() == dest_end - 1</code></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">basic_cstr_writer(CharT* dest, std::size_t dest_size);</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Precondition
</td>
<td class="hdlist2">
<p><code>dest_size != 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Postconditions
</td>
<td class="hdlist2">
<div class="ulist">
<ul>
<li>
<p><code>good() == true</code></p>
</li>
<li>
<p><code>pos() == dest</code></p>
</li>
<li>
<p><code>end() == dest + dest_size - 1</code></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">template &lt;std::size_t N&gt;
basic_cstr_writer(CharT (&amp;dest)[N]);</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions
</td>
<td class="hdlist2">
<div class="ulist">
<ul>
<li>
<p><code>good() == true</code></p>
</li>
<li>
<p><code>pos() == dest</code></p>
</li>
<li>
<p><code>end() == dest + N - 1</code></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">void recycle() noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions
</td>
<td class="hdlist2">
<div class="ulist">
<ul>
<li>
<p><code>good() == false</code></p>
</li>
<li>
<p><code>pos() == outbuf_garbage_buf&lt;CharT&gt;()</code></p>
</li>
<li>
<p><code>end() == outbuf_garbage_buf_end&lt;CharT&gt;()</code></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">result finish();</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effects
</td>
<td class="hdlist2">
<div class="ulist">
<ul>
<li>
<p>Assign to <code>'\0'</code> the position after the last written character in memory area used to initialize this object and set this object into "bad" state.</p>
</li>
</ul>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<div class="ulist">
<ul>
<li>
<p><code>result::truncated</code> is <code>true</code> if <code>recycle</code> or <code>finish</code> has ever been called in this object.</p>
</li>
<li>
<p><code>retulr::ptr</code> is the position after the last written character in memory area used to initialize this object</p>
</li>
</ul>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Postconditions
</td>
<td class="hdlist2">
<div class="ulist">
<ul>
<li>
<p><code>good() == false</code></p>
</li>
<li>
<p><code>pos() == outbuf_garbage_buf&lt;CharT&gt;()</code></p>
</li>
<li>
<p><code>end() == outbuf_garbage_buf_end&lt;CharT&gt;()</code></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="__code_discarded_outbuf_code">2.1.7. <code>discarded_outbuf</code></h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">namespace boost {

template &lt;typename CharT&gt;
class discarded_outbuf final: public basic_outbuf_noexcept&lt;CharT&gt;
{
public:
    discarded_outbuf();
    ~discarded_outbuf() = default;
    void recycle() noexcept override
};

} // namespace boost</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_public_member_functions_3">Public member functions</h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">discarded_outbuf();</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Posconditions
</td>
<td class="hdlist2">
<div class="ulist">
<ul>
<li>
<p><code>good() == false</code></p>
</li>
<li>
<p><code>pos() == outbuf_garbage_buf&lt;CharT&gt;()</code></p>
</li>
<li>
<p><code>end() == outbuf_garbage_buf_end&lt;CharT&gt;()</code></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">void recycle() noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Posconditions
</td>
<td class="hdlist2">
<div class="ulist">
<ul>
<li>
<p><code>good() == false</code></p>
</li>
<li>
<p><code>pos() == outbuf_garbage_buf&lt;CharT&gt;()</code></p>
</li>
<li>
<p><code>end() == outbuf_garbage_buf_end&lt;CharT&gt;()</code></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_header_code_boost_outbuf_iterator_hpp_code">2.2. Header <code>boost/outbuf/iterator.hpp</code></h3>
<div class="sect3">
<h4 id="__code_underlying_outbuf_iterator_code">2.2.1. <code>underlying_outbuf_iterator</code></h4>
<div class="sect4">
<h5 id="_synopsis_3">Synopsis</h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">template &lt;std::size_t CharSize&gt;
class underlying_outbuf_iterator
{
public:

    using char_type = underlying_outbuf_char_type&lt;CharSize&gt;;
    using value_type = void;
    using difference_type = void;
    using pointer = void;
    using reference = void;
    using iterator_category = std::output_iterator_tag;

    explicit underlying_outbuf_iterator(underlying_outbuf&lt;CharSize&gt;&amp;) noexcept;
    underlying_outbuf_iterator(const underlying_outbuf_iterator&lt;CharSize&gt;&amp;) noexcept;

    underlying_outbuf_iterator&amp; operator*() noexcept; // no-op
    underlying_outbuf_iterator&amp; operator++() noexcept; // no-op
    underlying_outbuf_iterator&amp; operator++(int) noexcept; // no-op
    underlying_outbuf_iterator&amp; operator=(char_type ch);
    underlying_outbuf_iterator&amp; operator=(const underlying_outbuf_iterator&amp;) noexcept;
};</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_public_member_functions_4">Public member functions</h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">explicit underlying_outbuf_iterator(underlying_outbuf&lt;CharSize&gt;&amp; ob) noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>Initializes the private <code>underlying_outbuf&lt;CharSize&gt;&amp;</code> with <code>ob</code></p>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">underlying_outbuf_iterator&amp; operator*() noexcept;
underlying_outbuf_iterator&amp; operator++() noexcept;
underlying_outbuf_iterator&amp; operator++(int) noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>Returns <code>*this</code>;</p>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">underlying_outbuf_iterator&amp; operator=(char_type ch);</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return
</td>
<td class="hdlist2">
<p><code>*this</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>same as <code><a href="#underlying_outbuf_put">put</a>(ob, ch)</code>, where <code>ob</code> is the reference
used to initialize this object.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="outbuf_iterator">2.2.2. <code>outbuf_iterator</code></h4>
<div class="sect4">
<h5 id="_synopsis_4">Synopsis</h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">template &lt;typename CharT&gt;
class outbuf_iterator
{
public:

    using char_type = CharT
    using value_type = void;
    using difference_type = void;
    using pointer = void;
    using reference = void;
    using iterator_category = std::output_iterator_tag;

    explicit outbuf_iterator(basic_outbuf&lt;CharT&gt;&amp;) noexcept;
    outbuf_iterator(const basic_outbuf&lt;CharT&gt;&amp;) noexcept;

    outbuf_iterator&amp; operator*() noexcept; // no-op
    outbuf_iterator&amp; operator++() noexcept; // no-op
    outbuf_iterator&amp; operator++(int) noexcept; // no-op
    outbuf_iterator&amp; operator=(char_type ch);
    outbuf_iterator&amp; operator=(const outbuf_iterator&amp;) noexcept;
};</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_public_member_functions_5">Public member functions</h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">explicit outbuf_iterator(basic_outbuf&lt;CharT&gt;&amp; ob) noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>Initializes the private <code>basic_outbuf&lt;CharT&gt;&amp;</code> with <code>ob</code></p>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">outbuf_iterator&amp; operator*() noexcept;
outbuf_iterator&amp; operator++() noexcept;
outbuf_iterator&amp; operator++(int) noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>Returns <code>*this</code>;</p>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">outbuf_iterator&amp; operator=(char_type ch);</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return
</td>
<td class="hdlist2">
<p><code>*this</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>same as <code><a href="#basic_outbuf_put">put</a>(ob, ch)</code>, where <code>ob</code> is the reference
used to initialize this object.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_header_code_boost_outbuf_string_hpp_code">2.3. Header <code>boost/outbuf/string.hpp</code></h3>
<div class="sect3">
<h4 id="__code_basic_string_maker_code">2.3.1. <code>basic_string_maker</code></h4>
<div class="sect4">
<h5 id="_synopsis_5">Synopsis</h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">namespace boost {

template &lt; typename CharT
         , typename Traits = std::char_traits&lt;CharT&gt;
         , typename Allocator = std::allocator&lt;CharT&gt; &gt;
class basic_string_maker final: public basic_outbuf&lt;CharT&gt;
{
public:
    basic_string_maker();
    void reserve(std::size_t size);
    void recycle() override;
    basic_string&lt;CharT, Traits, Allocator&gt; finish();
};

// Global type aliases

using string_maker    = basic_string_maker&lt;char&gt;;
using u16string_maker = basic_string_maker&lt;char16_t&gt;;
using u32string_maker = basic_string_maker&lt;char32_t&gt;;
using wstring_maker   = basic_string_maker&lt;wchar_t&gt;;
using u8string_maker  = basic_string_maker&lt;char8_t&gt;;

} // namespace boost</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_public_member_functions_6">Public member functions</h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">void reserve(std::size_t size);</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>Calls <code>str.reserve(size)</code>, where <code>str</code> is the private string object that is returned by <code>finish()</code>.</p>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">void recycle() override;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effects
</td>
<td class="hdlist2">
<div class="ulist">
<ul>
<li>
<p>If <code>good()</code> is <code>true</code> then calls <code>str.append(p0, pos())</code>, where <code>str</code> is the private string object that is returned by <code>finish()</code>, and <code>p0</code> is the return value of <code>pos()</code> before any call to <code>advance</code> and <code>advance_to</code> since the last call to <code>recycle()</code> ( all in this object ), or since this object&#8217;s contruction, whatever happened last.</p>
</li>
<li>
<p>Calls <code>set_pos</code> and/or <code>set_end</code>.</p>
</li>
</ul>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Postconditions
</td>
<td class="hdlist2">
<p><code>size() &gt;= min_size_after_recycle&lt;CharT&gt;()</code></p>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">basic_string&lt;CharT, Traits, Allocator&gt; finish()</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effects
</td>
<td class="hdlist2">
<p>Calls <code>recycle()</code> and <code>set_good(false)</code> and return the internal string.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Postconditions
</td>
<td class="hdlist2">
<p><code>good() == false</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="__code_basic_string_maker_noexcept_code">2.3.2. <code>basic_string_maker_noexcept</code></h4>
<div class="sect4">
<h5 id="_synopsis_6">Synopsis</h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">namespace boost {

template &lt; typename CharT
         , typename Traits = std::char_traits&lt;CharT&gt;
         , typename Allocator = std::allocator&lt;CharT&gt; &gt;
class basic_string_maker_noexcept final: public basic_outbuf_noexcept&lt;CharT&gt;
{
public:
    basic_string_maker_noexcept();
    void reserve(std::size_t size);
    void recycle() noexcept override;
    basic_string&lt;CharT, Traits, Allocator&gt; finish();
};

// Global type aliases

using string_maker_noexcept    = basic_string_maker_noexcept&lt;char&gt;;
using u16string_maker_noexcept = basic_string_maker_noexcept&lt;char16_t&gt;;
using u32string_maker_noexcept = basic_string_maker_noexcept&lt;char32_t&gt;;
using wstring_maker_noexcept   = basic_string_maker_noexcept&lt;wchar_t&gt;;
using u8string_maker_noexcept  = basic_string_maker_noexcept&lt;char8_t&gt;;

} // namespace boost</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_public_member_functions_7">Public member functions</h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">void reserve(std::size_t size);</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>Calls <code>str.reserve(size)</code>, where <code>str</code> is the private string object that is returned by <code>finish()</code>.</p>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">void recycle() override;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effects
</td>
<td class="hdlist2">
<div class="ulist">
<ul>
<li>
<p>If <code>good()</code> is <code>true</code> then calls <code>str.append(p0, pos())</code>, where <code>str</code> is the private string object that is returned by <code>finish()</code>, and <code>p0</code> is the return value of <code>pos()</code> before any call to <code>advance</code> and <code>advance_to</code> since the last call to <code>recycle()</code>, or since this object&#8217;s contruction, whatever happened last.</p>
</li>
<li>
<p>If an exception is thrown, hold it with a <code>std::exception_ptr</code> and calls <code>set_good(false)</code>.</p>
</li>
<li>
<p>Calls <code>set_pos</code> and/or <code>set_end</code>.</p>
</li>
</ul>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Postconditions
</td>
<td class="hdlist2">
<p><code>size() &gt;= min_size_after_recycle&lt;CharT&gt;()</code></p>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">basic_string&lt;CharT, Traits, Allocator&gt; finish()</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effects
</td>
<td class="hdlist2">
<div class="ulist">
<ul>
<li>
<p>Calls <code>recycle()</code> and <code>set_good(false)</code>.</p>
</li>
<li>
<p>Calls <code>std::rethrow_exception(eptr)</code> if <code>eptr</code> is not null, where <code>eptr</code> is
the internal <code>std::exception_ptr</code> that stores the exception thrown during <code>recycle()</code>.</p>
</li>
</ul>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Postconditions
</td>
<td class="hdlist2">
<p><code>good() == false</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="__code_basic_string_appender_code">2.3.3. <code>basic_string_appender</code></h4>
<div class="sect4">
<h5 id="_synopsis_7">Synopsis</h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">namespace boost {

template &lt; typename CharT
         , typename Traits = std::char_traits&lt;CharT&gt;
         , typename Allocator = std::allocator&lt;CharT&gt; &gt;
class basic_string_appender final: public basic_outbuf&lt;CharT&gt;
{
public:
    explicit basic_string_appender(basic_string&lt;CharT, Traits, Allocator&gt;&amp; dest);
    void reserve(std::size_t size);
    void recycle() override;
    void finish();
};

// Global type aliases

using string_appender    = basic_string_appender&lt;char&gt;;
using u16string_appender = basic_string_appender&lt;char16_t&gt;;
using u32string_appender = basic_string_appender&lt;char32_t&gt;;
using wstring_appender   = basic_string_appender&lt;wchar_t&gt;;

} // namespace boost</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_public_member_functions_8">Public member functions</h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">void reserve(std::size_t size);</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>Calls <code>str.reserve(str.size() + size)</code>, where <code>str</code> is the reference that this object was initialized with.</p>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">void recycle() override;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effects
</td>
<td class="hdlist2">
<div class="ulist">
<ul>
<li>
<p>If <code>good()</code> is <code>true</code> then calls <code>str.append(p0, pos())</code>, where <code>str</code> is the reference that this object was initialized with, and <code>p0</code> is the return value of <code>pos()</code> before any call to <code>advance</code> and <code>advance_to</code> since the last call to <code>recycle()</code> ( all in this object ), or since this object&#8217;s contruction, whatever happened last.</p>
</li>
<li>
<p>Calls <code>set_pos</code> and/or <code>set_end</code>.</p>
</li>
</ul>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Postconditions
</td>
<td class="hdlist2">
<p><code>size() &gt;= min_size_after_recycle&lt;CharT&gt;()</code></p>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">void finish()</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effects
</td>
<td class="hdlist2">
<p>Calls <code>recycle()</code> and <code>set_good(false)</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Postcondition
</td>
<td class="hdlist2">
<p><code>good() == false</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="__code_basic_string_appender_noexcept_code">2.3.4. <code>basic_string_appender_noexcept</code></h4>
<div class="sect4">
<h5 id="_synopsis_8">Synopsis</h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">namespace boost {

template &lt; typename CharT
         , typename Traits = std::char_traits&lt;CharT&gt;
         , typename Allocator = std::allocator&lt;CharT&gt; &gt;
class basic_string_appender_noexcept final: public basic_outbuf_noexcept&lt;CharT&gt;
{
public:
    explicit basic_string_appender_noexcept(basic_string&lt;CharT, Traits, Allocator&gt;&amp; dest);
    void reserve(std::size_t size);
    void recycle() override;
    void finish();
};

// Global type aliases

using string_appender_noexcept    = basic_string_appender_noexcept&lt;char&gt;;
using u16string_appender_noexcept = basic_string_appender_noexcept&lt;char16_t&gt;;
using u32string_appender_noexcept = basic_string_appender_noexcept&lt;char32_t&gt;;
using wstring_appender_noexcept   = basic_string_appender_noexcept&lt;wchar_t&gt;;

} // namespace boost</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_public_member_functions_9">Public member functions</h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">void reserve(std::size_t size);</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>Calls <code>str.reserve(str.size() + size)</code>, where <code>str</code> is the reference that this object was initialized with.</p>
</td>
</tr>
</table>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effects
</td>
<td class="hdlist2">
<div class="ulist">
<ul>
<li>
<p>If <code>good()</code> is <code>true</code> then calls <code>str.append(p0, pos())</code>, where <code>str</code> is the reference this object was initialized with, and <code>p0</code> is the return value of <code>pos()</code> before any call to <code>advance</code> and <code>advance_to</code> since the last call to <code>recycle()</code>, or since this object&#8217;s contruction, whatever happened last.</p>
</li>
<li>
<p>If an exception is thrown, hold it with a <code>std::exception_ptr</code> and calls <code>set_good(false)</code>.</p>
</li>
<li>
<p>Calls <code>set_pos</code> and/or <code>set_end</code>.</p>
</li>
</ul>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Postconditions
</td>
<td class="hdlist2">
<p><code>size() &gt;= min_size_after_recycle&lt;CharT&gt;()</code></p>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">void finish()</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effects
</td>
<td class="hdlist2">
<div class="ulist">
<ul>
<li>
<p>Calls <code>recycle()</code> and <code>set_good(false)</code>.</p>
</li>
<li>
<p>Calls <code>std::rethrow_exception(eptr)</code> if <code>eptr</code> is not null, where <code>eptr</code> is
the internal <code>std::exception_ptr</code> that stores the exception thrown during <code>recycle()</code>.</p>
</li>
</ul>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Postconditions
</td>
<td class="hdlist2">
<p><code>good() == false</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_header_code_boost_outbuf_streambuf_hpp_code">2.4. Header <code>boost/outbuf/streambuf.hpp</code></h3>
<div class="sect3">
<h4 id="__code_basic_streambuf_writer_code">2.4.1. <code>basic_streambuf_writer</code></h4>
<div class="sect4">
<h5 id="_synopsis_9">Synopsis</h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">namespace boost {

template &lt;typename CharT, typename Traits = std::char_traits&lt;CharT&gt; &gt;
class basic_streambuf_writer final: public boost::basic_outbuf&lt;CharT&gt;
{
public:
    explicit basic_streambuf_writer(std::basic_streambuf&lt;CharT, Traits&gt;&amp; dest);
    void recycle() override;
    struct result
    {
        std::streamsize count;
        bool success;
    };
    result finish();
};

// Global type aliases

using streambuf_writer
    = basic_streambuf_writer&lt;char, std::char_traits&lt;char&gt; &gt;;

using wstreambuf_writer
    = basic_streambuf_writer&lt;wchar_t, std::char_traits&lt;wchar_t&gt; &gt;;

} // namespace boost</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_public_member_functions_10">Public member functions</h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">void recycle() override;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effects
</td>
<td class="hdlist2">
<div class="ulist">
<ul>
<li>
<p>If <code>good()</code> is <code>true</code> then calls <code>dest.sputn(p0, pos() - p0)</code>, where <code>dest</code> is the reference this object was initialized with, and <code>p0</code> is the return value of <code>pos()</code> before any call to <code>advance</code> and <code>advance_to</code> since the last call to <code>recycle()</code>, or since this object&#8217;s contruction, whatever happened last.</p>
</li>
<li>
<p>If the returned value of <code>dest.sputn</code> is less then <code>pos() - p0</code>, calls <code>set_good(false)</code>.</p>
</li>
<li>
<p>Calls <code>set_pos</code> and/or <code>set_end</code>.</p>
</li>
</ul>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Postconditions
</td>
<td class="hdlist2">
<p><code>size() &gt;= min_size_after_recycle&lt;CharT&gt;()</code></p>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">result finish();</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effects
</td>
<td class="hdlist2">
<div class="ulist">
<ul>
<li>
<p>Calls <code>recycle()</code> and <code>set_good(false)</code>.</p>
</li>
</ul>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<div class="ulist">
<ul>
<li>
<p><code>result::count</code> is the sum of the values returned by <code>dest.sputn</code>.</p>
</li>
<li>
<p><code>result::success</code> is the value <code>good()</code> would return before this call to <code>finish()</code>.</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_header_code_boost_outbuf_cfile_hpp_code">2.5. Header <code>boost/outbuf/cfile.hpp</code></h3>
<div class="sect3">
<h4 id="__code_narrow_cfile_writer_code">2.5.1. <code>narrow_cfile_writer</code></h4>
<div class="sect4">
<h5 id="_synopsis_10">Synopsis</h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">namespace boost {

template &lt;typename CharT&gt;
class narrow_cfile_writer final: public boost::basic_outbuf_noexcept&lt;CharT&gt;
{
public:
    explicit narrow_cfile_writer(std::FILE* dest);
    void recycle() noexcept;
    struct result
    {
        std::size_t count;
        bool success;
    };
    result finish();
};
} // namespace boost</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_public_member_functions_11">Public member functions</h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">void recycle() override;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effects
</td>
<td class="hdlist2">
<div class="ulist">
<ul>
<li>
<p>If <code>good() == true</code>, calls <code>std::fwrite(p0, pos() - p0, sizeof(CharT), dest)</code>,
where <code>dest</code> is the <code>FILE*</code> used to initialize this object, and
<code>p0</code> is return value of <code>pos()</code> before any call to <code>advance</code> and <code>advance_to</code>
since the last call to <code>recycle()</code>, or since this object&#8217;s contruction,
whatever happened last.</p>
</li>
<li>
<p>If the returned value of std::fwrite is less then pos() - p0, calls set_good(false).</p>
</li>
<li>
<p>Calls set_pos and/or set_end.</p>
</li>
</ul>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Postconditions
</td>
<td class="hdlist2">
<p><code>size() &gt;= min_size_after_recycle&lt;CharT&gt;()</code></p>
</td>
</tr>
</table>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effects
</td>
<td class="hdlist2">
<div class="ulist">
<ul>
<li>
<p>Calls <code>recycle()</code> and <code>set_good(false)</code>.</p>
</li>
</ul>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<div class="ulist">
<ul>
<li>
<p><code>result::count</code> is the sum of values returned by all calls <code>std::fwrite</code> done by this object.</p>
</li>
<li>
<p><code>result::success</code> is the value <code>good()</code> would return before this call to <code>finish()</code></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="__code_wide_cfile_writer_code">2.5.2. <code>wide_cfile_writer</code></h4>
<div class="sect4">
<h5 id="_synopsis_11">Synopsis</h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">namespace boost {

template &lt;typename CharT&gt;
class wide_cfile_writer final: public boost::basic_outbuf_noexcept&lt;CharT&gt;
{
public:
    explicit wide_cfile_writer(std::FILE* dest);
    void recycle() noexcept;
    struct result
    {
        std::size_t count;
        bool success;
    };
    result finish();
};
} // namespace boost</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_public_member_functions_12">Public member functions</h5>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">void recycle() override;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effects
</td>
<td class="hdlist2">
<div class="ulist">
<ul>
<li>
<p>If <code>good() == true</code>, for each character <code>ch</code> in the range [ <code>p0</code>, <code>pos()</code> ) calls <code>std::fputwc(ch, dest)</code>, until WEOF is returned or the whole range is read, where <code>dest</code> is the <code>FILE*</code> used to initialize this object, and <code>p0</code> is the return value of <code>pos()</code> before any call to <code>advance</code> and <code>advance_to</code> since the last call to <code>recycle()</code>, or since this object&#8217;s contruction, whatever happened last.</p>
</li>
<li>
<p>If <code>std::fputwc</code> returns WEOF, calls <code>set_good(false)</code>.</p>
</li>
<li>
<p>Calls <code>set_pos</code> and/or <code>set_end</code>.</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">result finish();</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effects
</td>
<td class="hdlist2">
<div class="ulist">
<ul>
<li>
<p>Calls <code>recycle()</code> and <code>set_good(false)</code>.</p>
</li>
</ul>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<div class="ulist">
<ul>
<li>
<p><code>result::count</code> is the number of calls to <code>std::fputwc</code> by this object that did not return WEOF .</p>
</li>
<li>
<p><code>result::success</code> is the value <code>good()</code> would return before this call to <code>finish()</code></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2019-10-09 07:39:25 -03
</div>
</div>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.js"></script>
<script>prettyPrint()</script>
</body>
</html>
